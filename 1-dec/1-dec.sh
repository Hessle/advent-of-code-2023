#!/bin/bash

# just an exercise to write the same solution in a bash-script

# Read lines from 'input.txt' and split them by newline
linesFromFile() {
    cat input.txt
}

# Get the first digit from a line (optionally reverse the line)
getNumber() {
    local line="$1"
    local flipString="$2"
    if [[ "$flipString" == true ]]; then
        line=$(echo "$line" | rev)
    fi
    local nrRegex="[0-9]"
    local numberFound
    if [[ "$line" =~ $nrRegex ]]; then
        numberFound="${BASH_REMATCH[0]}"
        echo "$numberFound"
    fi
}

# Calculate the total by adding numbers from each line
getTotal() {
    local total=0
    while read -r line; do
        number1=$(getNumber "$line")
        number2=$(getNumber "$line" true)
        lineNumber="$number1$number2" # concatenate the numbers 1 and 2 to get 12
        total=$((total + lineNumber))
    done # < input.txt could also directly feed the file to the while loop
    # BUT then it needed to be written like this to catch the last line: while IFS= read -r line || [[ -n "$line" ]]; do
    # or a new line was necessary at the end of the file
    echo "$total"
}

# Main execution
lines=$(linesFromFile)
total=$(getTotal <<< "$lines")
echo "total is: $total"

# total=$() captures the output that would be generated by the function. That's why you don't see the output of line 34
# writing it like:
#   lines=$(linesFromFile)
#   getTotal <<< "$lines"
# would net the same result and would directly display the output of line 34
